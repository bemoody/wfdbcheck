/*
 * wfdbcheck - check for common mistakes in a WFDB record
 *
 * Copyright (c) 2018 Benjamin Moody
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>
#include <wfdb/wfdb.h>
#include <wfdb/ecgcodes.h>
#include <wfdb/wfdblib.h>

#ifndef NO_MESSAGES
#include "messages.h"
#endif

enum {
    MSG_INTERNAL,
    MSG_ERROR,
    MSG_WARNING,
    MSG_INFO,
    N_MSG_LEVELS
};

static int calopen_failed;

static int nsig;
static WFDB_Siginfo *siginfo;

static int nmssig;
static WFDB_Siginfo *mssiginfo;
static int *mssigskew;
static int *mssigused;
static WFDB_Sample *msminv;
static WFDB_Sample *msmaxv;
static WFDB_Frequency msffreq;

static int message_count[N_MSG_LEVELS];
static int output_level = MSG_INFO;
static int show_detail = 0;

/* Check if DESC appears to be a description that was
   automatically generated by isigopen, or a meaningless
   description generated by 'wrsamp'. */
static int is_auto_sigdesc(const char *desc)
{
    char *p;
    if (!strncmp(desc, "record ", 7) && strstr(desc, ", signal ") != NULL)
        return 1;
    if (!strncmp(desc, "col ", 4)) {
        strtol(desc + 4, &p, 10);
        if (*p == 0)
            return 1;
    }
    return 0;
}

/* Print an error/warning/info message, prefixed with
   details of the location of the error.  If FMT begins with
   an underscore, print the last error message from WFDB.
   Otherwise, treat FMT as a printf format string, and print
   the message followed by a newline.

   Each message should also have a detailed description,
   which is defined in messages.h.  That file is generated
   by the 'gen-messages' script, by extracting the text of
   the "DESCRIPTION" comments in this source file. */
#if __GNUC__ >= 3
__attribute__((format(printf, 6, 7)))
#endif
static void print_msg(int level, const char *msrec,
                      const char *rec, const char *ann,
                      int sig, const char *fmt, ...)
{
    va_list ap;
    int i;

    message_count[level]++;
    if (level > output_level)
        return;

    switch (level) {
    case MSG_INTERNAL: printf("(!!) "); break;
    case MSG_ERROR:    printf("(EE) "); break;
    case MSG_WARNING:  printf("(WW) "); break;
    case MSG_INFO:     printf("(II) "); break;
    }

    if (msrec != NULL)
        printf("%s:", msrec);
    if (rec != NULL)
        printf("%s:", rec);
    if (msrec != NULL || rec != NULL)
        printf(" ");
    if (ann != NULL)
        printf("annotator %s: ", ann);
    if (sig >= 0) {
        printf("signal %d", sig);
        if (rec) {
            if (sig < nsig && siginfo[sig].desc &&
                !is_auto_sigdesc(siginfo[sig].desc))
                printf(" (%s)", siginfo[sig].desc);
        }
        else {
            if (sig < nmssig && mssiginfo[sig].desc &&
                !is_auto_sigdesc(mssiginfo[sig].desc))
                printf(" (%s)", mssiginfo[sig].desc);
        }
        printf(": ");
    }

    if (fmt[0] == '_') {
        /* output from wfdberror includes \n */
        printf("%s", wfdberror());
    }
    else {
        va_start(ap, fmt);
        vprintf(fmt, ap);
        va_end(ap);
        printf("\n");
    }

    if (!show_detail || !fmt)
        return;

    for (i = 0; message_description[i]; i++) {
        if (!strcmp(message_description[i], fmt)) {
            for (i++; message_description[i]; i++)
                printf("     %s\n", message_description[i]);
            printf("\n");
            return;
        }
        while (message_description[i])
            i++;
    }
}

/* Check for problematic characters in record names. */
static int bad_record_name(const char *name)
{
    int i;

    for (i = 0; name[i]; i++) {
        if ((name[i] < 'a' || name[i] > 'z') &&
            (name[i] < 'A' || name[i] > 'Z') &&
            (name[i] < '0' || name[i] > '9') &&
            name[i] != '.' && name[i] != '-' &&
            name[i] != '_' && name[i] != '/')
            return 1;
    }

    while (name) {
        if (name[0] == '.' || name[0] == '-')
            return 1;

        if ((!strncasecmp(name, "aux", 3) ||
             !strncasecmp(name, "con", 3) ||
             !strncasecmp(name, "nul", 3) ||
             !strncasecmp(name, "prn", 3)) &&
            (name[3] == 0 || name[3] == '/' || name[3] == '.'))
            return 1;

        if ((!strncasecmp(name, "com", 3) ||
             !strncasecmp(name, "lpt", 3)) &&
            (name[3] >= '1' && name[3] <= '9') &&
            (name[4] == 0 || name[4] == '/' || name[4] == '.'))
            return 1;

        if ((name = strchr(name, '/')))
            name++;
    }

    return 0;
}

/* Check for problematic characters in annotator names. */
static int bad_annotator_name(const char *name)
{
    int i;

    for (i = 0; name[i]; i++) {
        if ((name[i] < 'a' || name[i] > 'z') &&
            (name[i] < 'A' || name[i] > 'Z') &&
            (name[i] < '0' || name[i] > '9') &&
            name[i] != '_')
            return 1;
    }

    return 0;
}

/* Check if string contains ASCII control characters. */
static int has_control_chars(const char *name)
{
    int i;

    for (i = 0; name[i]; i++) {
        if ((unsigned char) name[i] < 0x20 ||
            (unsigned char) name[i] == 0x7f)
            return 1;
    }
    return 0;
}

/* Check if string is all digits */
static int is_all_digits(const char *name)
{
    int i;

    for (i = 0; name[i]; i++) {
        if (name[i] < '0' || name[i] > '9')
            return 0;
    }

    return 1;
}

/* Check consistency of starting time/date. */
static int cmp_base_times(const char *t1,
                          const char *t2)
{
    const char *d1, *d2;

    /* If either is not an absolute timestamp, no comparison is
       possible */
    if (t1[0] != '[' || t2[0] != '[')
        return 0;

    /* Check whether t1 and/or t2 contain starting dates */
    d1 = strchr(t1, ' ');
    d2 = strchr(t2, ' ');

    if (d1 && d2)
        /* Both t1 and t2 include starting dates */
        return strcmp(t1, t2);
    else if (!d1 && !d2)
        /* both t1 and t2 include starting time of day only */
        return strcmp(t1, t2);
    else if (d1) {
        /* t1 includes a date but t2 includes only time of day */
        if ((int) strlen(t2) != d1 - t1 + 1)
            return 1;
        return strncmp(t1, t2, d1 - t1);
    }
    else {
        /* t2 includes a date but t1 includes only time of day */
        if ((int) strlen(t1) != d2 - t2 + 1)
            return 1;
        return strncmp(t1, t2, d2 - t2);
    }
}

/* Check that size of file is acceptable. */
static void check_file_size(const char *msrec, const char *rec,
                            const char *fname)
{
    WFDB_FILE *f;
    int size_valid = 1;

    f = wfdb_open(fname, NULL, WFDB_READ);

#ifdef EOVERFLOW
    if (!f && errno == EOVERFLOW)
        size_valid = 0;
#endif

    if (f) {
        if (!wfdb_fseek(f, 0L, SEEK_END) && wfdb_ftell(f) > 2147483647)
            size_valid = 0;
        wfdb_fclose(f);
    }

    if (!size_valid) {
        print_msg(MSG_WARNING, msrec, rec, NULL, -1,
                  "file %s larger than 2^31 bytes", fname);
/*DESCRIPTION: file %s larger than 2^31 bytes *//*
The length of this file is greater than 2,147,483,647 bytes,
which will cause problems for 32-bit applications and
filesystems.
*/
    }
}

/* Check for duplicate signal descriptions. */
static void check_sigdesc(const char *msrec, const char *rec,
                          int ns, const WFDB_Siginfo *si)
{
    int i, j, n;

    for (i = 0; i < ns; i++) {
        for (j = 0; j < i; j++)
            if (!strcmp(si[i].desc, si[j].desc))
                break;
        if (j != i)
            continue;

        n = 1;
        for (j++; j < ns; j++) {
            if (!strcmp(si[i].desc, si[j].desc))
                n++;
        }
        if (n > 1) {
            print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                      "%d signals named %s", n, si[i].desc);
/*DESCRIPTION: %d signals named %s *//*
This record contains two or more signals with the same
description.  If two or more signals have the same
description, users will be unable to select signals by
name.  In the case of variable-format multi-segment
records, only one of the two signals will be visible to
applications.
*/
        }
    }
}

/* Check for mismatches in signal info between first/layout segment
   and later segments. */
static void check_seg_siginfo(const char *msrec, const char *rec,
                              const WFDB_Sample *minv,
                              const WFDB_Sample *maxv)
{
    int i, j;
    int skew;
    const char *s1, *s2;
    double scale, offset, min_mapped, max_mapped;

    /* FIXME: for fixed layout, require signals to match exactly */

    for (i = 0; i < nsig; i++) {
        for (j = 0; j < nmssig; j++) {
            if (!strcmp(siginfo[i].desc, mssiginfo[j].desc)) {
                /* mark signal as used */
                mssigused[j] = 1;
                break;
            }
        }

        if (j == nmssig) {
            print_msg(MSG_ERROR, msrec, rec, NULL, i,
                      "signal not present in layout");
/*DESCRIPTION: signal not present in layout *//*
A signal in this segment is not listed in the record's
layout header.  As a result, this signal is not usable,
since applications will not be able to see it.
*/
        }
        else {
            s1 = siginfo[i].units;
            s2 = mssiginfo[j].units;
            if ((s1 && !s2) || (s2 && !s1) ||
                (s1 && s2 && strcmp(s1, s2) != 0)) {
                print_msg(MSG_ERROR, msrec, rec, NULL, i,
                          "wrong units (%s, expected %s)",
                          s1 ? s1 : "NULL",
                          s2 ? s2 : "NULL");
/*DESCRIPTION: wrong units (%s, expected %s) *//*
A signal in this segment uses different physical units than
the units specified in the layout header.  Physical units
must match in order for sample values to be scaled
correctly.
*/
            }

            if (siginfo[i].spf != mssiginfo[j].spf) {
                print_msg(MSG_ERROR, msrec, rec, NULL, i,
                          "wrong spf (%d, expected %d)",
                          siginfo[i].spf, mssiginfo[j].spf);
/*DESCRIPTION: wrong spf (%d, expected %d) *//*
A signal in this segment has a different number of samples
per frame than the number specified in the layout header.
The number of samples per frame for each signal must be
consistent throughout the record in order for applications
to read the signals correctly.
*/
            }

            /* FIXME: I'm pretty sure this actually doesn't work with
               10.6... and skewing is somewhat broken for VLMS
               anyway... */
            skew = wfdbgetskew(i);
            if (skew != mssigskew[j]) {
                print_msg(MSG_ERROR, msrec, rec, NULL, i,
                          "wrong skew (%d, expected %d)",
                          skew, mssigskew[j]);
/*DESCRIPTION: wrong skew (%d, expected %d) *//*
A signal in this segment has a different skew than the skew
specified in the layout header.  The skew for each signal
must be consistent throughout the record in order for
applications to read the signals correctly.
*/
            }

            if (siginfo[i].gain > mssiginfo[j].gain) {
                print_msg(MSG_WARNING, msrec, rec, NULL, i,
                          "loss of precision due to sample scaling");
/*DESCRIPTION: loss of precision due to sample scaling *//*
A signal in this segment has a larger gain than the gain
specified in the layout header.  As a result, the scaled
samples seen by the application will be less precise than
the original data.  Some programs that generate
multi-segment records have been known to cause this problem
by rounding fractional gain values, or by deliberately
reducing precision in order to avoid 16-bit overflows (which
are not an issue for modern WFDB applications.)
*/
            }

            if (minv[i] < maxv[i] && siginfo[i].gain != 0.0) {
                scale = mssiginfo[j].gain / siginfo[i].gain;
                offset = mssiginfo[j].baseline - scale * siginfo[i].baseline;
                min_mapped = minv[i] * scale + offset;
                max_mapped = maxv[i] * scale + offset;

                /* min_mapped could be greater than
                   max_mapped if one gain is negative.
                   that'd be weird but arguably useful in
                   some cases */
                if (min_mapped > WFDB_SAMPLE_MAX + 0.5 ||
                    max_mapped > WFDB_SAMPLE_MAX + 0.5 ||
                    min_mapped < WFDB_SAMPLE_MIN - 0.5 ||
                    max_mapped < WFDB_SAMPLE_MIN - 0.5) {
                    print_msg(MSG_ERROR, msrec, rec, NULL, i,
                              "integer overflow in scaled range"
                              " (%.0f, %.0f)", min_mapped, max_mapped);
/*DESCRIPTION: integer overflow in scaled range (%.0f, %.0f) *//*
The scaled range of this signal (i.e. the range of sample
values when translated into physical units according to the
segment header, then translated back to ADC units according
to the layout header) is larger than the range of sample
values supported by this version of the WFDB library.
(Currently, the maximum range is 32 bits on all supported
platforms.)
*/
                }
                else if (msminv[j] < msmaxv[j] &&
                         ((WFDB_Sample) min_mapped > msmaxv[j] ||
                          (WFDB_Sample) max_mapped > msmaxv[j] ||
                          (WFDB_Sample) min_mapped < msminv[j] ||
                          (WFDB_Sample) max_mapped < msminv[j])) {
                    print_msg(MSG_WARNING, msrec, rec, NULL, i,
                              "scaled range (%d, %d) exceeds"
                              " expected range (%d, %d)",
                              (int) min_mapped, (int) max_mapped,
                              msminv[j], msmaxv[j]);
/*DESCRIPTION: scaled range (%d, %d) exceeds expected range (%d, %d) *//*
The scaled range of this signal (i.e. the range of sample
values when translated into physical units according to the
segment header, then translated back to ADC units according
to the layout header) exceeds the stated ADC range given in
the layout header.  This will cause problems for
applications that rely on knowing the possible range of
sample values, such as applications that convert the signal
into other formats.  The 'resolution' and 'zero' values in
the layout header should be set according to the maximum
possible range of scaled sample values, rounded up to the
next power of two.
*/
                }
            }
        }
    }
}

/* Check if signal types are known. */
static void check_calinfo(const char *msrec, const char *rec,
                          int ns, const WFDB_Siginfo *si)
{
    int i;
    WFDB_Calinfo info;
    const char *units;

    if (calopen_failed)
        return;

    for (i = 0; i < ns; i++) {
        if (si[i].desc && is_auto_sigdesc(si[i].desc)) {
            print_msg(MSG_WARNING, msrec, rec, NULL, i,
                      "signal description missing");
/*DESCRIPTION: signal description missing *//*
A signal in this record has no description, or a generic
description such as "record foo, signal 0".  Signals should
be given a meaningful description, both for users' and for
applications' benefit.
*/
            continue;
        }
        else if (si[i].desc && is_all_digits(si[i].desc)) {
            print_msg(MSG_WARNING, msrec, rec, NULL, i,
                      "signal description is a number");
/*DESCRIPTION: signal description is a number *//*
A signal in this record has a description that is a decimal
number.  Signals should be given a meaningful description,
both for users' and for applications' benefit.  Moreover,
this name can cause confusion when using applications that
allow signals to be identified either by name or by number.
*/
            continue;
        }
        else if (si[i].desc && has_control_chars(si[i].desc)) {
            print_msg(MSG_ERROR, msrec, rec, NULL, i,
                      "control characters in signal description");
/*DESCRIPTION: control characters in signal description *//*
A signal in this record includes control characters in its
description.  Signal descriptions must be plain text.
*/
            continue;
        }

        units = (si[i].units ? si[i].units : "mV");
        if (has_control_chars(units)) {
            print_msg(MSG_ERROR, msrec, rec, NULL, i,
                      "control characters in unit name");
/*DESCRIPTION: control characters in unit name *//*
A signal in this record includes control characters in its
physical units.  Unit names must be plain text and may not
include whitespace.
*/
            continue;
        }

        if (getcal(si[i].desc, (char *) units, &info) < 0) {
            print_msg(MSG_WARNING, msrec, rec, NULL, -1,
                      "signal %s (units %s) not listed in calibration file",
                      si[i].desc, units);
/*DESCRIPTION: signal %s (units %s) not listed in calibration file *//*
A signal in this record does not correspond to a known entry
in the WFDB calibration file.  As a result, viewers will use
a default plotting scale for this signal, which tends to
give poor results.  If none of the existing signal types
accurately describe the signal, a new type should be added
to the calibration file.
*/
        }
    }
}

/* Get maximum resolution of a given WFDB signal format. */
static int format_bits(int fmt)
{
    switch (fmt) {
    case 0:   return 0;
    case 80:  return 8;
    case 310: return 10;
    case 311: return 10;
    case 212: return 12;
    case 16:  return 16;
    case 61:  return 16;
    case 160: return 16;
    case 24:  return 24;
    case 32:  return 32;
    case 8:   return 32;
    default:
        if (fmt > 100 && fmt % 100 > 0 && fmt % 100 <= 32)
            return (fmt % 100);
        else
            return -1;
    }
}

/* Get the internal sample value corresponding to WFDB_INVALID_SAMPLE. */
static WFDB_Sample format_sample_sentinel(int fmt)
{
    int bits = format_bits(fmt);

    if (fmt == 8 || bits < 2)
        return WFDB_INVALID_SAMPLE;

    return -((WFDB_Sample) 1 << (bits - 2)) * 2;
}

/* Check consistency of a list of annotators. */
static void check_annotators(char *msrec, char *rec,
                             char **annotators, int optional,
                             WFDB_Time nframes)
{
    WFDB_Time nsamp;
    WFDB_Anninfo ai;
    WFDB_Annotation annot, prev;
    int type_predefined[ACMAX+1], type_defined[ACMAX+1],
        type_described[ACMAX+1], type_checked[ACMAX+1];
    int warned_invalid;
    int i, type;
    int first;
    char empty[] = "", invalid[] = "\377";

    nsamp = nframes * getspf();

    for (i = 0; i <= ACMAX; i++)
        type_predefined[i] = (anndesc(i) && anndesc(i)[0] != '\377');

    for (; *annotators; annotators++) {
        ai.name = *annotators;
        ai.stat = WFDB_READ;

        /* reset type strings so that we can see what custom types are
           defined by the annotation file */
        for (i = 0; i <= ACMAX; i++) {
            if (type_predefined[i]) {
                setannstr(i, ecgstr(i));
                setanndesc(i, empty);
            }
            else {
                setannstr(i, invalid);
                setanndesc(i, invalid);
            }
            type_checked[i] = 0;
        }
        warned_invalid = 0;

        i = annopen(rec, &ai, 1);
        if (i < 0) {
            if (i != -3 || !optional) {
                print_msg(MSG_ERROR, msrec, rec, ai.name, -1, "_annopen");
/*DESCRIPTION: _annopen *//*
This annotation file cannot be read or is not properly
formatted.
*/
            }
            continue;
        }

        /* FIXME: time resolution should be explicit
           (especially if record is multifrequency, but it's
           a good idea in general.)

           also, make sure we are correctly checking bounds
           for multifrequency records (both EDF and non-EDF)
        */

        for (i = 0; i <= ACMAX; i++) {
            type_defined[i] = (annstr(i) && annstr(i)[0] != '\377');
            type_described[i] = (anndesc(i) && anndesc(i)[0] != '\377');

            if (type_defined[i] && !type_described[i]) {
                print_msg(MSG_WARNING, msrec, rec, ai.name, -1,
                          "no description for annotation type '%s'",
                          annstr(i));
/*DESCRIPTION: no description for annotation type '%s' *//*
A custom annotation type defined in this file does not
include a description.  This usually means that the program
that created the annotation file called the setannstr()
function without calling setanndesc().
*/
            }
            if (type_defined[i] && strann(annstr(i)) != i) {
                print_msg(MSG_WARNING, msrec, rec, ai.name, -1,
                          "multiple annotation codes with mnemonic '%s'",
                          annstr(i));
/*DESCRIPTION: multiple annotation codes with mnemonic '%s' *//*
A custom annotation type defined in this file uses a
mnemonic that conflicts with another custom annotation type,
or with a built-in annotation type.  To avoid ambiguity,
annotation mnemonics should be unique.
*/
            }
        }

        first = 1;
        prev.time = 0;
        while (getann(0, &annot)) {
            if (first) {
                first = 0;
                if (annot.time < 0) {
                    print_msg(MSG_WARNING, msrec, rec, ai.name, -1,
                              "first annotation is at s%ld",
                              annot.time);
/*DESCRIPTION: first annotation is at s%ld *//*
Annotations in this file occur before the start of the
record.  This is usually a mistake.
*/
               }
            }
            else {
                if (annot.time < prev.time) {
                    print_msg(MSG_ERROR, msrec, rec, ai.name, -1,
                              "annotations out of order (s%ld > s%ld)",
                              prev.time, annot.time);
/*DESCRIPTION: annotations out of order (s%ld > s%ld) *//*
Annotations in this file are not stored in chronological
order.  If the program that generates the annotations writes
them out of order, they should be sorted afterwards using
sortann (which is done automatically if the annotations are
written using the WFDB library.)
*/
                }
            }

            type = annot.anntyp;
            if (type < 0 || type > ACMAX) {
                if (!warned_invalid) {
                    print_msg(MSG_ERROR, msrec, rec, ai.name, -1,
                              "invalid annotation [%d] at s%ld",
                              type, annot.time);
/*DESCRIPTION: invalid annotation [%d] at s%ld *//*
This file contains one or more annotations with invalid
types.  These may have been created by a broken application,
or by a future version of WFDB that is incompatible with the
version you are using.
*/
                    warned_invalid = 1;
                }
            }
            else if (!type_checked[type]) {
                if (type == 0) {
                    print_msg(MSG_WARNING, msrec, rec, ai.name, -1,
                              "null annotation at s%ld",
                              annot.time);
/*DESCRIPTION: null annotation at s%ld *//*
This file contains one or more "type 0" annotations.
Annotation type 0 is reserved for internal use, and should
not appear in published annotation files.
*/
                }
                else if (!type_defined[type]) {
                    print_msg(MSG_WARNING, msrec, rec, ai.name, -1,
                              "undefined annotation [%d] at s%ld",
                              type, annot.time);
/*DESCRIPTION: undefined annotation [%d] at s%ld *//*
This file contains one or more custom annotation types, but
these types have not been defined in the file header.
Custom annotation types should be defined by calling
setannstr() and setanndesc() before writing the annotation
file.
*/
                }
                type_checked[type] = 1;
            }
            prev = annot;
        }

        if (nsamp > 0 && prev.time > nsamp) {
            print_msg(MSG_WARNING, msrec, rec, ai.name, -1,
                      "last annotation is after end of signals (s%ld)",
                      prev.time);
/*DESCRIPTION: last annotation is after end of signals (s%ld) *//*
Annotations in this file occur after the end of the signals.
This is usually a mistake.
*/
        }
    }

    for (i = 0; i <= ACMAX; i++) {
        if (type_predefined[i])
            setanndesc(i, empty);
        else
            setanndesc(i, invalid);
    }
}

/* Check consistency of a single-segment record */
static void check_segment(char *msrec, char *rec,
                          char *wfdbpath, int nheasig,
                          const char *baset, WFDB_Time nframes,
                          WFDB_Time *nframes_read)
{
    WFDB_Seginfo *segs;
    WFDB_Sample *vec = NULL, *minv = NULL, *maxv = NULL, *invv = NULL,
        *minsamp = NULL, *maxsamp = NULL, v;
    unsigned int *sum = NULL;
    int *sample_warned = NULL;
    int totalspf, maxspf, i, j, s, fsmin, fsmax, dmax, stat,
        plusadcres, minusadcres, baseadcres;
    WFDB_Frequency ffreq;
    WFDB_Time t;

    wfdbquit();
    setwfdb(wfdbpath);

    if (nframes_read)
        *nframes_read = 0;

    if (msrec)
        /* kludge to ensure msrec is added to the search path, as if
           we called isigopen() */
        wfdbfile((char *) "hea", msrec);

    if (nheasig == 0) {
        nheasig = isigopen(rec, NULL, 0);
        if (nheasig < 0) {
            print_msg(MSG_ERROR, msrec, rec, NULL, -1, "_isigopen");
/*DESCRIPTION: _isigopen *//*
The header file for this record (or the EDF header) cannot
be read or is not properly formatted.
*/
            return;
        }
        else if (nheasig == 0) {
            if (msrec) {
                print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                          "segment with no signals");
/*DESCRIPTION: segment with no signals *//*
This segment contains no signals.  Empty portions of the
record must be indicated with a gap segment ('~'), rather
than a header file with no signals.
*/
            }
            else {
                print_msg(MSG_INFO, msrec, rec, NULL, -1, "no signals");
/*DESCRIPTION: no signals *//*
This record contains no signals, which is usually a mistake.
*/
            }
            return;
        }
    }

    SALLOC(siginfo, nheasig, sizeof(WFDB_Siginfo));
    nsig = isigopen(rec, siginfo, -nheasig);
    if (nsig < 0) {
        print_msg(MSG_ERROR, msrec, rec, NULL, -1, "_isigopen");
        SFREE(siginfo);
        return;
    }
    else if (nsig != nheasig) {
        print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                  "unable to read signal info");
/*DESCRIPTION: unable to read signal info *//*
The WFDB library was unable to read the metadata for all
signals.  This is probably a bug.
*/
        SFREE(siginfo);
        return;
    }

    totalspf = 0;
    maxspf = 1;
    for (i = 0; i < nsig; i++) {
        totalspf += siginfo[i].spf;
        if (siginfo[i].spf > maxspf)
            maxspf = siginfo[i].spf;
    }

    if (nsig > 0) {
        SUALLOC(minv, nsig, sizeof(WFDB_Sample));
        SUALLOC(maxv, nsig, sizeof(WFDB_Sample));
        SUALLOC(vec, totalspf, sizeof(WFDB_Sample));
        SUALLOC(invv, nsig, sizeof(WFDB_Sample));
        SUALLOC(minsamp, nsig, sizeof(WFDB_Sample));
        SUALLOC(maxsamp, nsig, sizeof(WFDB_Sample));
        SUALLOC(sum, nsig, sizeof(unsigned int));
        SUALLOC(sample_warned, nsig, sizeof(int));
    }

    if (siginfo[0].nsamp < 0) {
        print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                  "negative record length (%ld)", siginfo[0].nsamp);
/*DESCRIPTION: negative record length (%ld) *//*
The length specified in this record's header file is
negative.  This makes no sense.
*/
    }
    else if (siginfo[0].nsamp == LONG_MAX ||
             siginfo[0].nsamp - 1 >= 2147483647 / maxspf) {
        /* Note that this will complain about records that are exactly
           LONG_MAX frames long (since isigopen can't distinguish this
           from a record longer than LONG_MAX.)  This isn't really a
           problem; records anywhere near that length should be split
           up if 32-bit compatibility is an issue. */
        print_msg(MSG_INFO, msrec, rec, NULL, -1,
                  "record length greater than 2^31 samples");
/*DESCRIPTION: record length greater than 2^31 samples *//*
The length of this record is greater than 2,147,483,647
samples, which will cause problems for 32-bit applications.
*/
    }

    setgvmode(WFDB_LOWRES);
    ffreq = sampfreq(NULL);
    if (ffreq <= 0.0) {
        print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                  "record frame frequency invalid");
/*DESCRIPTION: record frame frequency invalid *//*
The frame frequency of this record is invalid or
unspecified.
*/
    }
    else if (msffreq > 0.0 && ffreq != msffreq) {
        print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                  "wrong frame frequency (%g, expected %g)",
                  ffreq, msffreq);
/*DESCRIPTION: wrong frame frequency (%g, expected %g) *//*
The frame frequency of this segment does not match the frame
frequency of the master header.
*/
    }

    if (baset && cmp_base_times(baset, mstimstr(0))) {
        print_msg(MSG_WARNING, msrec, rec, NULL, -1,
                  "wrong base time (%s, expected %s)",
                  mstimstr(0), baset);
/*DESCRIPTION: wrong base time (%s, expected %s) *//*
The starting time (and/or date) of this segment are not
consistent with the starting time of the master header.
*/
    }

    if (getseginfo(&segs) > 0) {
        print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                  "nested multi-segment record");
/*DESCRIPTION: nested multi-segment record *//*
This segment is a multi-segment record.  Multi-segment
records may not be nested within another multi-segment
record.
*/
    }

    /* Check signal descriptions */
    check_sigdesc(msrec, rec, nsig, siginfo);

    /* Check that signals are known */
    if (!msrec)
        check_calinfo(msrec, rec, nsig, siginfo);

    /* Check signal information */
    for (i = 0; i < nsig; i++) {
        if (siginfo[i].fmt == 0)
            continue;

        if (i == 0 || siginfo[i].group != siginfo[i - 1].group) {
            if (bad_record_name(siginfo[i].fname)) {
                print_msg(MSG_WARNING, msrec, rec, NULL, -1,
                          "problematic file name: %s",
                          siginfo[i].fname);
/*DESCRIPTION: problematic file name: %s *//*
The name of this signal file contains characters that may be
problematic on some platforms.  The only characters that are
universally safe to use are the ASCII digits (0-9), letters
(a-z, A-Z), underscore (_), dot and dash (., -) other than
at the beginning of a file name, and slash (/) used as a
directory separator.  Other characters are potentially
problematic, as they are either considered special by the
shell, disallowed or considered special in URLs, disallowed
in Windows filenames, or considered special by the WFDB
library or applications themselves.  Certain names (such as
'con' and 'aux') are also forbidden as Windows filenames.
*/
            }
            check_file_size(msrec, rec, siginfo[i].fname);
        }

        if (siginfo[i].fmt == 8) {
            print_msg(MSG_WARNING, msrec, rec, NULL, i,
                      "signal stored in difference format");
/*DESCRIPTION: signal stored in difference format *//*
A signal in this record is stored in a "format 8" compressed
data file.  This format is not recommended, as it causes
problems for applications that do not read the signal file
sequentially.  (The format was designed as an intermediate
format for data collection on embedded systems with
extremely limited storage, but nowadays there are much
better options.)
*/
        }

        if (siginfo[i].gain == 0.0) {
            if (msrec) {
                print_msg(MSG_ERROR, msrec, rec, NULL, i,
                          "gain not specified");
/*DESCRIPTION: gain not specified *//*
The gain of this signal is not specified.  The gain must be
given explicitly for all signals and all segments of a
multi-segment record.  Note that dimensionless values should
typically use units of "NU".
*/
            }
            else {
                print_msg(MSG_WARNING, msrec, rec, NULL, i,
                          "gain not specified");
            }
        }
        else if (siginfo[i].gain < 0.0) {
            print_msg(MSG_INFO, msrec, rec, NULL, i,
                      "negative gain (%g)", siginfo[i].gain);
/*DESCRIPTION: negative gain (%g) *//*
The gain of this signal is negative (meaning that larger
sample values represent smaller physical values.)  This is
usually a mistake.
*/
        }

        if (siginfo[i].adcres == 0) {
            print_msg(MSG_WARNING, msrec, rec, NULL, i,
                      "adcres = 0");
/*DESCRIPTION: adcres = 0 *//*
The ADC resolution of this signal (i.e., the number of bits
used in raw sample values) is set to zero.  Some
applications may do this if they do not know the resolution
of their input; it will cause problems when converting the
data into other formats.  (If the signal is not directly
captured by a binary ADC, the 'resolution' and 'zero' values
should still be set according to the maximum possible range
of sample values, rounded up to the next power of two.)
*/
        }
        else if (siginfo[i].adcres < 0) {
            print_msg(MSG_ERROR, msrec, rec, NULL, i,
                      "negative adcres (%d)", siginfo[i].adcres);
/*DESCRIPTION: negative adcres (%d) *//*
The ADC resolution of this signal is negative.  This makes
no sense.
*/
        }

        j = format_bits(siginfo[i].fmt);
        if (j < 0) {
            print_msg(MSG_INTERNAL, msrec, rec, NULL, i,
                      "unknown format %d", siginfo[i].fmt);
/*DESCRIPTION: unknown format %d *//*
The version of the WFDB library does not match this version
of wfdbcheck.
*/
            fsmin = INT_MIN;
            fsmax = INT_MAX;
        }
        else if (siginfo[i].adcres > j) {
            print_msg(MSG_ERROR, msrec, rec, NULL, i,
                      "format %d is insufficient for adcres %d",
                      siginfo[i].fmt, siginfo[i].adcres);
/*DESCRIPTION: format %d is insufficient for adcres %d *//*
The specified ADC resolution is greater than the number of
bits per sample in the signal file.  This may mean that the
signal file has been converted improperly (and the sample
values have either been clipped or wrapped), or it may mean
that the specified ADC resolution is incorrect.
*/
            fsmin = INT_MIN;
            fsmax = INT_MAX;
        }
        else {
            fsmax = ((int) ((1U << (j - 1)) - 1));
            fsmin = -fsmax - 1;
        }

        if (siginfo[i].adcres > 0 && siginfo[i].adcres <= 32) {
            dmax = (int) ((1U << (siginfo[i].adcres - 1)) - 1);
            if (siginfo[i].adczero > INT_MAX - dmax ||
                siginfo[i].adczero < INT_MIN + dmax + 1) {
                print_msg(MSG_ERROR, msrec, rec, NULL, i,
                          "integer overflow in ADC range"
                          " (zero=%d, res=%d)",
                          siginfo[i].adczero, siginfo[i].adcres);
/*DESCRIPTION: integer overflow in ADC range (zero=%d, res=%d) *//*
The specified ADC range is larger than the range of sample
values supported by this version of the WFDB library.
(Currently, this is 32 bits on all supported platforms.)
*/
                minv[i] = maxv[i] = 0;
            }
            else {
                minv[i] = siginfo[i].adczero - dmax - 1;
                maxv[i] = siginfo[i].adczero + dmax;
                if (minv[i] < fsmin || maxv[i] > fsmax) {
                    print_msg(MSG_ERROR, msrec, rec, NULL, i,
                              "format %d is insufficient for ADC range"
                              " (zero=%d, res=%d)",
                              siginfo[i].fmt, siginfo[i].adczero,
                              siginfo[i].adcres);
/*DESCRIPTION: format %d is insufficient for ADC range (zero=%d, res=%d) *//*
The specified ADC range is larger than the range of sample
values supported by the signal file format.  This may mean
that the signal file has been converted improperly (and the
sample values have either been clipped or wrapped), or it
may mean that the specified ADC resolution is incorrect.
*/
                }
            }
        }
        else {
            /* no need for an error message here - less than 0
               or more than 32 will trigger an error above */
            minv[i] = maxv[i] = 0;
        }
    }

    for (i = 0; i < nsig; i++) {
        invv[i] = format_sample_sentinel(siginfo[i].fmt);
        minsamp[i] = WFDB_SAMPLE_MAX;
        maxsamp[i] = WFDB_SAMPLE_MIN;
    }

    /* Check that each signal matches a signal in the layout */
    if (msrec)
        check_seg_siginfo(msrec, rec, minv, maxv);

    /* Read signals */

    nsig = isigopen(rec, siginfo, nheasig);
    if (nsig < 0) {
        print_msg(MSG_ERROR, msrec, rec, NULL, -1, "_isigopen");
    }
    else if (nsig != nheasig) {
        print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                  "unable to read signal file(s)");
/*DESCRIPTION: unable to read signal file(s) *//*
Some or all of the signal files listed for this record do
not exist or cannot be read.
*/
    }

    if (nsig > 0) {
        if (nframes == 0 && siginfo[0].nsamp > 0)
            nframes = siginfo[0].nsamp;

        /* Check that samples are in range */
        t = 0;
        while ((stat = getframe(vec)) >= 0 || stat == -4) {
            for (i = s = 0; i < nsig; i++) {
                for (j = 0; j < siginfo[i].spf; j++, s++) {
                    if (vec[s] == WFDB_INVALID_SAMPLE) {
                        sum[i] += invv[i];
                        continue;
                    }
                    sum[i] += vec[s];
                    if (vec[s] < minsamp[i]) minsamp[i] = vec[s];
                    if (vec[s] > maxsamp[i]) maxsamp[i] = vec[s];
                    if (vec[s] >= minv[i] && vec[s] <= maxv[i])
                        continue;
                    if (!sample_warned[i]) {
                        sample_warned[i] = 1;
                        if (siginfo[i].spf > 1)
                            print_msg(MSG_ERROR, msrec, rec, NULL, i,
                                      "frame %ld, sample %d (%d) is"
                                      " outside ADC range (%d, %d)",
                                      t, j, vec[s], minv[i], maxv[i]);
/*DESCRIPTION: frame %ld, sample %d (%d) is outside ADC range (%d, %d) *//*
One or more samples exceed the stated ADC range for this
signal.  This will cause problems for applications that rely
on knowing the possible range of sample values, such as
applications that convert the signal into other formats.
(If the signal is not directly captured by a binary ADC, the
ADC resolution should still equal the base-2 logarithm of
the range of sample values, rounded up.)
*/
                        else
                            print_msg(MSG_ERROR, msrec, rec, NULL, i,
                                      "sample %ld (%d) is outside"
                                      " ADC range (%d, %d)",
                                      t, vec[s], minv[i], maxv[i]);
/*DESCRIPTION: sample %ld (%d) is outside ADC range (%d, %d) *//*
One or more samples exceed the stated ADC range for this
signal.  This will cause problems for applications that rely
on knowing the possible range of sample values, such as
applications that convert the signal into other formats.
(If the signal is not directly captured by a binary ADC, the
ADC resolution should still equal the base-2 logarithm of
the range of sample values, rounded up.)
*/
                    }
                }
            }
            t++;
            if (stat == -4)
                break;
        }

        /* Check for bad checksum / truncated data file */
        if (stat == -4) {
            for (i = 0; i < nsig; i++) {
                if (siginfo[i].cksum != (short) (sum[i] & 0xffff)) {
                    print_msg(MSG_ERROR, msrec, rec, NULL, i,
                              "checksum error (%d, expected %d)",
                              (int) (short) (sum[i] & 0xffff),
                              siginfo[i].cksum);
/*DESCRIPTION: checksum error (%d, expected %d) *//*
The stated checksum for this signal is incorrect.  Either
the header was not written correctly, or the signal file has
been corrupted.
*/
                    stat = -1;
                }
            }
            if (stat == -4) {
                print_msg(MSG_ERROR, msrec, rec, NULL, -1, "_getframe(-4)");
/*DESCRIPTION: _getframe(-4) *//*
The stated checksums for one or more signals are incorrect.
Either the header was not written correctly, or the signal
file has been corrupted.
*/
            }
        }
        else if (stat == -3) {
            print_msg(MSG_ERROR, msrec, rec, NULL, -1, "_getframe(-3)");
/*DESCRIPTION: _getframe(-3) *//*
The stated length is incorrect for one or more signals.
Either the header was not written correctly, or the signal
file has been corrupted.
*/
        }
        else if (stat != -1) {
            print_msg(MSG_ERROR, msrec, rec, NULL, -1, "_getframe(*)");
/*DESCRIPTION: _getframe(*) *//*
An error occurred while reading the signal file.
*/
        }
        /* Check that record length is consistent with master header */
        else if (nframes != 0 && nframes != t) {
            print_msg(MSG_ERROR, msrec, rec, NULL, -1,
                      "wrong record length (%ld frames, expected %ld)",
                      t, nframes);
/*DESCRIPTION: wrong record length (%ld frames, expected %ld) *//*
The stated record length is incorrect.  Either the header
was not written correctly, or the signal file has been
corrupted.
*/
        }

        if (siginfo[0].nsamp == 0) {
            print_msg(MSG_WARNING, msrec, rec, NULL, -1,
                      "record length not specified (%ld frames)", t);
/*DESCRIPTION: record length not specified (%ld frames) *//*
The header for this record does not specify the length
(total number of samples.)  Header files should specify the
length of the signals, with the exception of special header
files used for streaming I/O.
*/
        }

        if (nframes_read)
            *nframes_read = t;
    }

    for (i = 0; i < nsig; i++) {
        if (!sample_warned[i]) {
            plusadcres = 0;
            v = maxsamp[i];
            while (v > 0) {
                v /= 2;
                plusadcres++;
            }
            if (minsamp[i] > 0) {
                minusadcres = -1;
            }
            else {
                minusadcres = 0;
                v = -(minsamp[i] + 1);
                while (v > 0) {
                    v /= 2;
                    minusadcres++;
                }
            }

            if (minusadcres < 0)
                baseadcres = plusadcres;
            else if (minusadcres > plusadcres)
                baseadcres = minusadcres + 1;
            else
                baseadcres = plusadcres + 1;

            if (siginfo[i].adcres > baseadcres) {
                print_msg(MSG_INFO, msrec, rec, NULL, i,
                          "signal range (%d, %d) < (%d, %d)",
                          minsamp[i], maxsamp[i],
                          minv[i], maxv[i]);
/*DESCRIPTION: signal range (%d, %d) < (%d, %d) *//*
The actual signal range is less than the stated ADC range.
The ADC range may be incorrect.
*/
            }
        }
    }

    SFREE(siginfo);
    SFREE(vec);
    SFREE(minv);
    SFREE(maxv);
    SFREE(invv);
    SFREE(minsamp);
    SFREE(maxsamp);
    SFREE(sum);
    SFREE(sample_warned);
}

/* Check consistency of a complete record */
static void check_record(char *rec,
                         char **required_annotators,
                         char **optional_annotators,
                         char *wfdbpath)
{
    WFDB_Seginfo *segs, *wsegs;
    char **baset;
    int nheasig, nsegs, i, j, dmax;
    int n, segnum = -1;
    WFDB_Time nframes;
    char *tmp;

    wfdbquit();
    setwfdb(wfdbpath);

    if (bad_record_name(rec)) {
        print_msg(MSG_WARNING, NULL, rec, NULL, -1,
                  "problematic character(s) in record name");
/*DESCRIPTION: problematic character(s) in record name *//*
The name of this record contains characters that may be
problematic on some platforms.  The only characters that are
universally safe to use are the ASCII digits (0-9), letters
(a-z, A-Z), underscore (_), dot and dash (., -) other than
at the beginning of a file name, and slash (/) used as a
directory separator.  Other characters are potentially
problematic, as they are either considered special by the
shell, disallowed or considered special in URLs, disallowed
in Windows filenames, or considered special by the WFDB
library or applications themselves.  Certain names (such as
'con' and 'aux') are also forbidden as Windows filenames.
*/
    }

    nheasig = isigopen(rec, NULL, 0);
    if (nheasig < 0) {
        print_msg(MSG_ERROR, NULL, rec, NULL, -1, "_isigopen");
        return;
    }
    if (nheasig == 0) {
        print_msg(MSG_INFO, NULL, rec, NULL, -1, "no signals");
        return;
    }

    nsegs = getseginfo(&wsegs);
    if (nsegs <= 0) {
        check_segment(NULL, rec, wfdbpath, nheasig, NULL, 0, &nframes);
        check_annotators(NULL, rec, required_annotators, 0, nframes);
        check_annotators(NULL, rec, optional_annotators, 1, nframes);
        return;
    }

    /* Multi-segment record */

    SUALLOC(segs, nsegs, sizeof(WFDB_Seginfo));
    memcpy(segs, wsegs, nsegs * sizeof(WFDB_Seginfo));

    nframes = segs[nsegs - 1].samp0 + segs[nsegs - 1].nsamp;
    check_annotators(rec, NULL, required_annotators, 0, nframes);
    check_annotators(rec, NULL, optional_annotators, 1, nframes);

    setgvmode(WFDB_LOWRES);
    msffreq = sampfreq(NULL);
    if (msffreq <= 0.0) {
        print_msg(MSG_ERROR, NULL, rec, NULL, -1,
                  "record frame frequency invalid");
    }

    /* Read signal info and save a copy */
    SALLOC(mssiginfo, nheasig, sizeof(WFDB_Siginfo));
    SALLOC(mssigskew, nheasig, sizeof(int));
    SALLOC(mssigused, nheasig, sizeof(int));
    SALLOC(msminv, nheasig, sizeof(WFDB_Sample));
    SALLOC(msmaxv, nheasig, sizeof(WFDB_Sample));
    nmssig = isigopen(rec, mssiginfo, -nheasig);
    if (nmssig < 0) {
        print_msg(MSG_ERROR, NULL, rec, NULL, -1, "_isigopen");
        return;
    }
    else if (nmssig != nheasig) {
        print_msg(MSG_ERROR, NULL, rec, NULL, -1,
                  "unable to read signal info");
    }

    for (i = 0; i < nmssig; i++) {
        if (mssiginfo[i].desc) {
            tmp = NULL;
            SSTRCPY(tmp, mssiginfo[i].desc);
            mssiginfo[i].desc = tmp;
        }
        if (mssiginfo[i].units) {
            tmp = NULL;
            SSTRCPY(tmp, mssiginfo[i].units);
            mssiginfo[i].units = tmp;
        }

        mssigskew[i] = wfdbgetskew(i);
        mssigused[i] = 0;
        msminv[i] = msmaxv[i] = 0;

        if (mssiginfo[i].adcres == 0) {
            print_msg(MSG_WARNING, NULL, rec, NULL, i,
                      "adcres = 0");
        }
        else if (mssiginfo[i].adcres < 0) {
            print_msg(MSG_ERROR, NULL, rec, NULL, i,
                      "negative adcres (%d)", mssiginfo[i].adcres);
        }
        else if (mssiginfo[i].adcres > 32) {
            print_msg(MSG_ERROR, NULL, rec, NULL, i,
                      "adcres too large (%d)", mssiginfo[i].adcres);
/*DESCRIPTION: adcres too large (%d) *//*
The specified ADC range is larger than the range of sample
values supported by this version of the WFDB library.
(Currently, this is 32 bits on all supported platforms.)
*/
        }
        else {
            dmax = (int) ((1U << (mssiginfo[i].adcres - 1)) - 1);
            if (mssiginfo[i].adczero > INT_MAX - dmax ||
                mssiginfo[i].adczero < INT_MIN + dmax - 1) {
                print_msg(MSG_ERROR, NULL, rec, NULL, i,
                          "integer overflow in ADC range"
                          " (zero=%d, res=%d)",
                          mssiginfo[i].adczero, mssiginfo[i].adcres);
            }
            else {
                msminv[i] = mssiginfo[i].adczero - dmax - 1;
                msmaxv[i] = mssiginfo[i].adczero + dmax;
            }
        }
    }

    /* Check signal descriptions */
    check_sigdesc(rec, NULL, nmssig, mssiginfo);

    /* Check that signals are known */
    check_calinfo(rec, NULL, nmssig, mssiginfo);

    /* Get expected base time for each segment */
    SUALLOC(baset, nsegs, sizeof(char *));
    for (i = 0; i < nsegs; i++)
        SSTRCPY(baset[i], mstimstr(-segs[i].samp0));

    /* Check segments */
    for (i = 0; i < nsegs; i++) {
        if (strlen(segs[i].recname) >= 4 &&
            !strcmp(segs[i].recname + strlen(segs[i].recname) - 4, ".hea")) {
            print_msg(MSG_ERROR, rec, segs[i].recname, NULL, -1,
                      "'.hea' in master header");
/*DESCRIPTION: '.hea' in master header *//*
The name of this segment includes a '.hea' suffix, which is
not necessary and may cause problems.
*/
        }

        if (strcmp(segs[i].recname, "~") &&
            bad_record_name(segs[i].recname)) {
            print_msg(MSG_WARNING, rec, segs[i].recname, NULL, -1,
                      "problematic character(s) in segment name");
/*DESCRIPTION: problematic character(s) in segment name *//*
The name of this segment contains characters that may be
problematic on some platforms.  The only characters that are
universally safe to use are the ASCII digits (0-9), letters
(a-z, A-Z), underscore (_), dot and dash (., -) other than
at the beginning of a file name, and slash (/) used as a
directory separator.  Other characters are potentially
problematic, as they are either considered special by the
shell, disallowed or considered special in URLs, disallowed
in Windows filenames, or considered special by the WFDB
library or applications themselves.  Certain names (such as
'con' and 'aux') are also forbidden as Windows filenames.
*/
        }

        if (i == 0 && segs[i].nsamp == 0) /* layout header */
            continue;

        if (!strcmp(segs[i].recname, "~")) /* gap */
            continue;

        /* Warn if segments appear to be numbered but are not
           sequential */
        j = strlen(segs[i].recname);
        while (j > 0 &&
               segs[i].recname[j - 1] >= '0' &&
               segs[i].recname[j - 1] <= '9')
            j--;
        if (segs[i].recname[j] != 0) {
            n = atoi(segs[i].recname + j);
            if (segnum >= 0 && n != segnum + 1) {
                print_msg(MSG_INFO, rec, NULL, NULL, -1,
                          "segment number %d is followed by %d",
                          segnum, n);
/*DESCRIPTION: segment number %d is followed by %d *//*
The names of the segments in this record appear to be
numbered, but the numbers are not sequential.  This might be
a mistake.
*/
            }
            else if (segnum < 0 && j > 0 && n > 1) {
                print_msg(MSG_INFO, rec, NULL, NULL, -1,
                          "segment numbers begin with %d",
                          n);
/*DESCRIPTION: segment numbers begin with %d *//*
The names of the segments in this record appear to be
numbered, but the first segment is not numbered 0 or 1.
This might be a mistake.
*/
            }
            segnum = n;
        }

        check_segment(rec, segs[i].recname, wfdbpath,
                      0, baset[i], segs[i].nsamp, NULL);
    }

    /* Warn about unused signals in layout */
    for (i = 0; i < nmssig; i++) {
        if (!mssigused[i]) {
            print_msg(MSG_INFO, rec, NULL, NULL, i,
                      "signal not present in any segment");
/*DESCRIPTION: signal not present in any segment *//*
A signal listed in the record's layout header is not present
in any segment of the record.  This is likely to cause
confusion for users.
*/
        }
    }

    for (i = 0; i < nmssig; i++) {
        SFREE(mssiginfo[i].desc);
        SFREE(mssiginfo[i].units);
    }
    SFREE(mssiginfo);
    SFREE(mssigskew);
    SFREE(mssigused);
    SFREE(msminv);
    SFREE(msmaxv);

    for (i = 0; i < nsegs; i++)
        SFREE(baset[i]);

    SFREE(baset);
    SFREE(segs);
}

static char *prog_name(char *s)
{
    char *p = s + strlen(s);

#ifdef MSDOS
    while (p >= s && *p != '\\' && *p != ':') {
        if (*p == '.')
            *p = '\0';          /* strip off extension */
        if ('A' <= *p && *p <= 'Z')
            *p += 'a' - 'A';    /* convert to lower case */
        p--;
    }
#else
    while (p >= s && *p != '/')
        p--;
#endif
    return (p+1);
}

int main(int argc, char **argv)
{
    static const char usage[] =
        "Usage: %s [-v] [-q] [-r] record ... [-a annotator ...]\n"
        "Options:\n"
        "  -r:   record names follow\n"
        "  -a:   annotator names follow\n"
        "  -A:   optional annotator names follow\n"
        "  -v:   show detailed description for each error/warning message\n"
        "  -q:   hide less severe messages (use -q -q for even less)\n";
    int i, argtype, nr, na1, na2;
    char *pname;
    char *path = NULL;
    char **records;
    char **required_annotators;
    char **optional_annotators;
    char *annotator;
    int records_from_stdin = 0;
    char buf[256];

    pname = prog_name(argv[0]);

    SUALLOC(records, argc, sizeof(char *));
    SUALLOC(required_annotators, argc, sizeof(char *));
    SUALLOC(optional_annotators, argc, sizeof(char *));

    nr = na1 = na2 = 0;
    argtype = 'r';
    for (i = 1; i < argc; i++) {
        if (!strcmp(argv[i], "-r")) {
            argtype = 'r';
        }
        else if (!strcmp(argv[i], "-a")) {
            argtype = 'a';
        }
        else if (!strcmp(argv[i], "-A")) {
            argtype = 'A';
        }
        else if (!strcmp(argv[i], "-v")) {
            show_detail = 1;
        }
        else if (!strcmp(argv[i], "-q")) {
            output_level--;
        }
        else if (!strcmp(argv[i], "-")) {
            records_from_stdin = 1;
        }
        else if (argv[i][0] == '-') {
            fprintf(stderr, "%s: unrecognized option %s\n",
                    pname, argv[i]);
            return 4;
        }
        else {
            switch (argtype) {
            case 'a':
                required_annotators[na1] = argv[i];
                na1++;
                break;
            case 'A':
                optional_annotators[na2] = argv[i];
                na2++;
                break;
            case 'r':
                records[nr] = argv[i];
                nr++;
                break;
            }
        }
    }
    if (nr == 0 && !records_from_stdin) {
        fprintf(stderr, usage, pname);
        return 4;
    }
    required_annotators[na1] = NULL;
    optional_annotators[na2] = NULL;

    SSTRCPY(path, getwfdb());

    wfdbquiet();

    if (calopen(NULL) < 0) {
        print_msg(MSG_WARNING, NULL, NULL, NULL, -1, "_calopen");
/*DESCRIPTION: _calopen *//*
The WFDB calibration file cannot be read.  Signal types will
not be checked.
*/
        calopen_failed = 1;
    }

    for (i = 0; i < na1 + na2; i++) {
        if (i < na1)
            annotator = required_annotators[i];
        else
            annotator = optional_annotators[i - na1];
        if (bad_annotator_name(annotator)) {
            print_msg(MSG_WARNING, NULL, NULL, annotator, -1,
                      "problematic character(s) in annotator name");
/*DESCRIPTION: problematic character(s) in annotator name *//*
The name of this annotator contains characters that may be
problematic on some platforms.  The only characters that are
safe to use in annotator names are the ASCII digits (0-9),
letters (a-z, A-Z), and underscore (_).
*/
        }
        else if (is_all_digits(annotator)) {
            print_msg(MSG_WARNING, NULL, NULL, annotator, -1,
                      "annotator name is all digits");
/*DESCRIPTION: annotator name is all digits *//*
The name of this annotator is entirely digits.  This may
cause confusion.
*/
        }
    }

    for (i = 0; i < nr; i++)
        check_record(records[i], required_annotators,
                     optional_annotators, path);

    if (records_from_stdin) {
        while (fgets(buf, sizeof(buf), stdin)) {
            i = strlen(buf);
            while (i > 0 && (buf[i - 1] == '\r' || buf[i - 1] == '\n'))
                buf[--i] = 0;
            if (i > 0)
                check_record(buf, required_annotators,
                             optional_annotators, path);
        }
    }

    SFREE(path);
    SFREE(records);
    SFREE(required_annotators);
    SFREE(optional_annotators);

    if (message_count[MSG_INTERNAL])
        return 3;
    else if (message_count[MSG_ERROR])
        return 2;
    else if (message_count[MSG_WARNING])
        return 1;
    else
        return 0;
}

/*
Local Variables:
c-basic-offset: 4
indent-tabs-mode: nil
fill-column: 60
End:
*/
